---
title: "Desafio_07"
author: "RafaelaB"
format: html
editor: visual
---

## Aula 07

```{r}
library(RSQLite)
library(tidyverse)
path <- getwd()


if(!"discoCopy.db" %in% list.files(path)){
file.copy("../Downloads/disco.db", "../Downloads/discoCopy.db")
} # Modificaremos esse arquivo

```

```{r}
db = dbConnect(SQLite(),
"../Downloads/discoCopy.db")
```

```{r}
dbListTables(db)
```

A sintaxe para criar uma tabela vazia, no SQLite, é através do comando CREATE TABLE nome (col1 tipo, col2 tipo2, ...)

```{r}
#dbExecute(db,
#"CREATE TABLE instruments
#(AlbumId INTEGER,
#TrackId INTEGER,
#ElectricGuitar INTEGER,
#Singer INTEGER,
#Trumpet INTEGER)")
```

**Removendo uma tabela**

```{r}
dbListFields(db, 'instruments')
```

Você pode remover uma tabela usando o comando DROP TABLE nome:

```{r}
dbExecute(db, "DROP TABLE instruments")
```

A tabela 'instruments' foi removida.

*Em geral, DROP TABLE é perigoso. Se você abrir seu servidor, pode ficar sujeito aos chamados "injection attacks"!*

```{r}
dbListTables(db)
```

**BOAS PRÁTICAS**

Colhe inputs do usuário em aname e diz quais álbums deste artista estão listados:

```{r}
aname = "Gilberto Gil"
sql = paste0("SELECT ArtistId FROM artists "
,
"WHERE Name = '"
, aname,
"'")
aId = dbGetQuery(db, sql)
sql = paste('SELECT Title FROM albums'
,
'WHERE ArtistId ='
, aId)
dbGetQuery(db, sql)

```

Podem inserir informações que podem mexer no banco de dados:

```{r}
aname <- "Gilberto Gil'; DROP TABLE 'albums"
```

Opção segura:

```{r}
sql = paste("SELECT ArtistId FROM artists"
,
"WHERE Name = ?")
query <- dbSendQuery(db, sql)
dbBind(query, list("Gilberto Gil"))
aId <- dbFetch(query)
dbClearResult(query)
# Segundo passo interno, não deve causar problema
sql = paste('SELECT Title FROM albums'
,
'WHERE ArtistId ='
, aId)
dbGetQuery(db, sql)

```

**Incluindo linhas em uma tabela**

Voltando ao caso de instrumentos, suponha que eu tenha criado a tabela "instruments", e quero completá-la com alguma informação. Uma maneira de fazê-lo é usando o comando `INSERT INTO` tabela `VALUES (...)`

```{r}
dbExecute(db,
"CREATE TABLE instruments
(AlbumId INTEGER,
TrackId INTEGER,
ElectricGuitar INTEGER,
Singer INTEGER,
Trumpet INTEGER)")

dbListFields(db,'instruments')
```

```{r}
# Eu Tu Eles: AlbumId 85,
sql = paste('SELECT TrackId, Name FROM tracks'
,
'WHERE AlbumId = 85')
dbGetQuery(db, sql) %>% head()

dbExecute(db,
"INSERT INTO instruments
VALUES ('85','1075', 0, 1, 0),
('85','1078', 0, 1, 0); ")

dbGetQuery(db,
"SELECT * FROM instruments")
```

**Inserindo em uma tabela diferente**

O data.frame mtcars é um exemplo famoso de data frame no R. Eu vou incluí-lo no nosso banco de dados:

```{r}
#dbWriteTable(db,"mtcars", mtcars)
dbListTables(db)
```

Note que o atributo rownames (marcas dos carros) foi perdido! Mas há um parâmetro row.names em dbWriteTable.

```{r}
dbGetQuery(db,"SELECT * FROM mtcars") %>% head(3)
```

**Inserindo uma tabela diretamente: `append`**

O parâmetro append concatena uma tabela nova a dados existentes. Por exemplo:

```{r}
theAvgCar <- mtcars %>%
summarise_all(function(x) round(mean(x), 2))
theAvgCar
```

```{r}
dbWriteTable(db,"mtcars", theAvgCar, append = TRUE) #Comando para colocar uma tabela dentro de outra
dbGetQuery(db,"SELECT * FROM mtcars") %>% tail(3)
```

**Inserindo uma tabela diretamente: `overwrite`**

O parâmetro overwrite sobrescreve a tabela (use com cuidado!).

```{r}
dbWriteTable(db,"mtcars", mtcars, overwrite = TRUE)
dbGetQuery(db,"SELECT * FROM mtcars") %>% tail(3)

```

**Lendo chunk:**

Em certo sentido, dbGetQuery() é um atalho para dbSendQuery() seguido de dbFetch() (e dbClearResult()). Uma vantagem de usar a *sintaxe mais longa* é que podemos ler dados em chunks:

```{r}
res <- dbSendQuery(db,
"SELECT * FROM mtcars WHERE cyl = 4")
while(!dbHasCompleted(res)){
chunk <- dbFetch(res, n = 5)
print(nrow(chunk))
}

dbClearResult(res)
```

**Fechando conexões**

Fechando conexão e removendo a cópia

```{r}

if("discoCopy.db" %in% list.files(path)){
file.remove("../Downloads/discoCopy.db")
}
dbDisconnect(db)
```

## **Criando a base de dados**

```{r}
airports <- read_csv("../Downloads/airports.csv"
, col_types = "cccccdd")
airlines <- read_csv("../Downloads/airlines.csv"
, col_types = "cc")
air <- dbConnect(SQLite(), dbname="../Downloads/air.db")
#dbWriteTable(air, name = "airports"
#, airports)
#dbWriteTable(air, name = "airlines"
#, airlines)
dbListTables(air)
```

```{r}

if("air.db" %in% list.files(path)){
file.remove("../Downloads/air.db")
}
dbDisconnect(air)
```

**Argumentos do `dplyr()`**

```{r}
db <- dbConnect(SQLite(),
"../Downloads/disco.db") # original

tracks <- tbl(db,
"tracks") # dplyr
tracks %>% head(3)

meanTracks <- tracks %>%
group_by(AlbumId) %>%
summarise(AvLen = mean(Milliseconds, na.rm = TRUE),
AvCost = mean(UnitPrice, na.rm = TRUE))
meanTracks

meanTracks %>% show_query()

```

```{r}
mT <- meanTracks %>% collect()
mT

```

## 
